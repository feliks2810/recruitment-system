// ... existing code ...
            
            <table class="w-full calendar-table">
                <thead>
                    <tr>
// ... existing code ...
                        <th class="py-3 text-xs font-semibold text-gray-500 uppercase border-b border-r-0 border-gray-200">Min</th>
                    </tr>
                </thead>
                <tbody id="calendarTableBody">
                    {{-- Calendar body will be generated by JS --}}
                </tbody>
            </table>
        </div>

        <div class="lg:col-span-1">
// ... existing code ...
// ... existing code ...
    let currentMonth = currentDate.getMonth();
    let currentYear = currentDate.getFullYear();
    let selectedDateKey = null;
    const eventsByDate = {};

    function updateCalendar() {
        if (!calendarTableBody) return;
        document.getElementById('currentMonth').textContent = `${months[currentMonth]} ${currentYear}`;
        calendarTableBody.innerHTML = '';
        const firstDay = new Date(currentYear, currentMonth, 1);
        const startDayIndex = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1;
        const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
        const prevMonthLastDay = new Date(currentYear, currentMonth, 0).getDate();

        let dayCounter = 1;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
// ... existing code ...
// ... existing code ...
        }
    }

    async function fetchAndMarkEvents() {
// ... existing code ...
            const response = await fetch('{{ route("events.calendar") }}');
            if (!response.ok) throw new Error('Failed to fetch events');
            const allEventsData = await response.json();
            processEvents(allEventsData);
// ... existing code ...
// ... existing code ...
        for (const key in eventsByDate) { delete eventsByDate[key]; }
        if (!Array.isArray(events)) return;
        events.forEach(item => {
            if (!item || !item.date) return;
            const dateKey = item.date;
            if (!eventsByDate[dateKey]) eventsByDate[dateKey] = [];
            eventsByDate[dateKey].push(item);
        });
    }

    function markEventDays() {
        document.querySelectorAll('.calendar-cell.has-event').forEach(c => c.classList.remove('has-event'));
        for (const dateKey in eventsByDate) {
            const cell = document.querySelector(`[data-date-key="${dateKey}"]`);
// ... existing code ...
// ... existing code ...
    function initialize() {
        updateCalendar();
        fetchAndMarkEvents();
        document.getElementById('prevMonth').addEventListener('click', () => navigateMonth(-1));
        document.getElementById('nextMonth').addEventListener('click', () => navigateMonth(1));
        
        const addEventBtn = document.getElementById('addEventBtn');
        const addEventModal = document.getElementById('addEventModal');
        const closeModalBtn = document.getElementById('closeModal');
        const addEventForm = document.getElementById('addEventForm');

        if (addEventBtn && addEventModal && closeModalBtn && addEventForm) {
            addEventBtn.addEventListener('click', () => {
                addEventModal.classList.add('show');
                document.getElementById('eventDate').value = selectedDateKey || new Date().toISOString().slice(0, 10);
            });

            closeModalBtn.addEventListener('click', () => {
                addEventModal.classList.remove('show');
            });

            window.addEventListener('click', (event) => {
                if (event.target == addEventModal) {
                    addEventModal.classList.remove('show');
                }
            });

            addEventForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                const formData = new FormData(this);
                const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

                try {
                    const response = await fetch(this.action, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest',
                            'X-CSRF-TOKEN': csrfToken
                        },
                        body: formData
                    });

                    const result = await response.json();

                    if (response.ok && result.success) {
                        addEventModal.classList.remove('show');
                        this.reset();
                        await fetchAndMarkEvents();
                        if (selectedDateKey) {
                            filterMeetingsByDate(selectedDateKey);
                        }
                        alert('Jadwal berhasil ditambahkan!');
                    } else {
                        let errorMessage = 'Gagal menambahkan jadwal.';
                        if (result.errors) {
                            errorMessage += '\n' + Object.values(result.errors).flat().join('\n');
                        } else if (result.message) {
                            errorMessage = result.message;
                        }
                        alert(errorMessage);
                    }
                } catch (error) {
                    console.error('Error submitting form:', error);
                    alert('Terjadi kesalahan jaringan atau server.');
                }
            });
        }
    }
    
    initialize();
    
    // Other functions (selectDate, filterMeetingsByDate, etc.) remain the same
// ... existing code ...
// ... existing code ...
        const meetingsList = document.getElementById('meetingsList');
        const noMeetings = document.getElementById('noMeetings');
        const eventsForDate = eventsByDate[dateKey] || [];
        
        meetingsList.innerHTML = '';

        if (eventsForDate.length > 0) {
            noMeetings.classList.add('hidden');
            meetingsList.classList.remove('hidden');
            eventsForDate.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            eventsForDate.forEach(item => {
// ... existing code ...
                const isCustom = item.is_custom;
                const title = isCustom ? item.title : item.title;
                const subtitle = isCustom ? item.description : item.description;
                const link = isCustom ? 'javascript:void(0);' : item.url;
                const itemHtml = `
                    <div class="flex items-center justify-between gap-3 p-3 bg-slate-50 rounded-lg group hover:bg-slate-100 transition-colors">
                        <a href="${link}" class="flex-1 min-w-0 ${isCustom ? 'cursor-default' : ''}">
                            <p class="font-semibold text-slate-800 truncate text-sm">${title}</p>
                            <p class="text-xs text-slate-500 truncate">${subtitle}</p>
                        </a>
                        ${isCustom ? `<button type="button" data-event-id="${item.id}" class="delete-event-btn text-gray-400 hover:text-red-600 opacity-0 group-hover:opacity-100"><i class="fas fa-trash-alt"></i></button>` : `<i class="fas fa-chevron-right text-gray-400"></i>`}
                    </div>`;
                meetingsList.innerHTML += itemHtml;
            });

            // Add event listeners for delete buttons
            document.querySelectorAll('.delete-event-btn').forEach(button => {
// ... existing code ...
// ... existing code ...
                        const response = await fetch(`/events/${eventId}`, {
                            method: 'DELETE',
                            headers: {
// ... existing code ...
                        if (response.ok && result.success) {
                            alert('Jadwal berhasil dihapus!');
                            await fetchAndMarkEvents(); // Re-fetch and update calendar
                            filterMeetingsByDate(dateKey);
                        } else {
                            let errorMessage = 'Gagal menghapus jadwal.';
                            if(result && result.message) {
                                errorMessage = result.message;
                            }
                            alert(errorMessage);
// ... existing code ...